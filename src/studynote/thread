线程的状态:::
新建：当创建Thread的实例后，此线程进行新建状态。如：Thread t1 = new Thread() 。
      （但是也有一些博客对这个提出了强烈的反对，认为new Thread()只是创建了一个普通的Java对象而已，
       和线程或者线程的状态八竿子打不着，不过认为创建Thread实例后，线程就处于新建状态的说法确实是主流）
就绪：当调用了start方法后，线程不会马上执行，此时线程的状态是“就绪”，等待分配CPU资源。
运行：线程获得CPU资源后，真正开始执行。
死亡：当线程运行结束后，进入“死亡”状态，处于此状态的线程永远都不会再次进入“就绪”。
阻塞：由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，就进入了“阻塞”的状态，
      比如调用线程的sleep方法，对象的wait方法等。当满足条件被返回后，线程重新进入“就绪”的状态，再次等待分配CPU资源。

线程通知与等待:::
wait
当一个线程调用共享变量的wait方法后，该线程会被阻塞挂起，直到发生以下的两个事情才返回：
  其他线程调用了该对象的notify或者notifyAll方法；
  其他线程调用了该线程的interrupt方法，该线程会被返回，并且抛出InterruptedException异常。
  调用wait方法后，还会释放对共享变量的监视器锁，让其他线程可以进入临界区
notify
唤醒等待获取对象监视器锁的线程
被唤醒的线程不能马上从wait方法处返回，并且继续执行，
因为还需要再次获取共享变量的监视器锁（因为调用wait方法后，已经释放了监视器，所以这里需要再次获取）。
如果有多个线程都调用了共享变量的wait方法而被阻塞挂起，那么调用notify方法后，只会随机唤醒其中一个线程。
还有一点尤其需要注意：当调用共享变量的notify方法后，并没有释放共享变量的监视器锁，
只有退出临界区(方法执行完毕)或者调用wait方法后，才会释放共享变量的监视器锁
join
一个线程调用另一个线程的join, 让另一个线程执行完 再接着执行本线程
yield
我们知道线程是以时间片的机制来占用CPU资源并运行的，
正常情况下，一个线程只有把分配给自己的时间片用完之后，线程调度器才会进行下一轮的线程调度，
当执行了Thread的yield后，就告诉操作系统“我不需要CPU了，你现在就可以进行下一轮的线程调度了 ”，
但是操作系统可以忽略这个暗示，也有可能下一轮还是把时间片分配给了这个线程。
sleep 和 yield 区别
当线程调用sleep后，会阻塞当前线程指定的时间，在这段时间内，线程调度器不会调用此线程，
当指定的时间结束后，该线程的状态为“就绪”，等待分配CPU资源。
当线程调用yield后，不会阻塞当前线程，只是让出时间片，回到“就绪”的状态，等待分配CPU资源。

死锁:::
死锁是指多个线程在执行的过程中，因为争夺资源而造成的相互等待的现象，而且无法打破这个“僵局”。
死锁的四个必要条件：
互斥：指线程对于已经获取到的资源进行排他性使用，即该资源只能被一个线程占有，如果还有其他线程也想占有，只能等待，直到占有资源的线程释放该资源。
请求并持有：指一个线程已经占有了一个资源，但是还想占有其他的资源，但是其他资源已经被其他线程占有了，所以当前线程只能等待，等待的同时并不释放自己已经拥有的资源。
不可剥夺：当一个线程获取资源后，不能被其他线程占有，只有在自己使用完毕后自己释放资源。
环路等待：即 T1线程正在等待T2占有的资源，T2线程正在等待T3线程占有的资源，T3线程又在等待T1线程占有的资源。
要想打破“死锁”僵局，只需要破坏以上四个条件中的任意一个，
但是程序员可以干预的只有“请求并持有”，“环路等待”两个条件，
其余两个条件是锁的特性，程序员是无法干预的。
聪明的你，一定看出来了，所谓“死锁”就是“悲观锁”造成的，相对于“死锁”，还有一个“活锁”，就是“乐观锁”造成的。

守护线程与用户线程:::
Java中的线程分为两类，分别为 用户线程和守护线程。
在JVM启动时，会调用main函数，这个就是用户线程，
JVM内部还会启动一些守护线程，比如垃圾回收线程。
那么守护线程和用户线程到底有什么区别呢？
当最后一个用户线程结束后，JVM就自动退出了，而不管当前是否有守护线程还在运行。

interrupt
中断线程。当线程A运行（:::非阻塞:::）时，线程B可以调用线程A的interrupt方法来设置线程A的中断标记为true，
这里要特别注意，调用interrupt方法并不会真的去中断线程，只是设置了中断标记为true，
线程A还是活的好好的。
如果线程A被阻塞了，比如调用了sleep、wait、join，
线程A会在调用这些方法的地方抛出“InterruptedException”。
但是还有一点需要注意，当我们catch住InterruptedException异常后，
“中断标记”会被重置为false
在介绍sleep，wait，join方法的时候，如果中断 调用这些方法而被阻塞的线程会抛出异常，
但是还有一点需要注意，当我们catch住InterruptedException异常后，“中断标记”会被重置为false




