CAS原理和原子操作类:
CAS的全称是Compare And Swap，即比较交换，当然还有一种说法：Compare And Set，调用原生CAS操作需要确定三个值：
  要更新的字段
  预期值
  新值

Java8对于原子操作类的优化:
在进行incrementAndGet源码解析的时候，
说到一个问题：在高并发之下，N多线程进行自旋竞争同一个字段，
这无疑会给CPU造成一定的压力，所以在Java8中，提供了更完善的原子操作类：LongAdder。
我们简单的说下它做了什么优化，
它内部维护了一个数组Cell[]和base，Cell里面维护了value，
在出现竞争的时候，JDK会根据算法，选择一个Cell，对其中的value进行操作，
如果还是出现竞争，会换一个Cell再次尝试，
最终把Cell[]里面的value和base相加，得到最终的结果。


伪共享:
我们知道CPU和内存之间的关系：
当CPU需要一个数据，会先去缓存中找，如果缓存中没有，会去内存找，
找到了，就把数据复制到缓存中，下次直接去缓存中取出即可。
但是这种说法，并不完善，在缓存中的数据，是以缓存行的形式存储的，
什么意思呢？就是一个缓存行可能不止一个数据。
假如一个缓存行的大小是64字节，CPU去内存中取数据，会把临近的64字节的数据都取出来，然后复制到缓存。
这对于单线程，是一种优化。
试想一下，如果CPU需要A数据，把临近的BCDE数据都从内存中取出来，
并且放入缓存了，CPU如果再需要BCDE数据，就可以直接去缓存中取了。
但在多线程下就有劣势了，因为同一缓存行的数据，同时只能被一个线程读取，这就叫伪共享了。
有没有办法可以解决这问题呢？
聪明的开发者想到了一个办法：如果缓存行的大小是64字节，我可以加上一些冗余字段来填充到64字节。
比如我只需要一个long类型的字段，现在我再加上6个long类型的字段作为填充，
一个long占8字节，现在是7个long类型的字段，也就是56字节，
另外对象头也占8个字节，正好64字节，正好够一个缓存行。
但是这种办法不够优雅，
所以在Java8中推出了@jdk.internal.vm.annotation.Contended注解，来解决伪共享的问题。
但是如果开发者想用这个注解， 需要添加 JVM 参数，具体参数我在这里就不说了，因为我没有亲测过。





