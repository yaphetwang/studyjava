package sometests.classloader;

/**
 * @author wyf
 * @date 2019/10/2 11:35
 * @description
 *
 * 到了初始化阶段，用户定义的 Java 程序代码才真正开始执行。
 * 在这个阶段，JVM 会根据语句执行顺序对类对象进行初始化，
 * 一般来说当 JVM 遇到下面 5 种情况的时候会触发初始化：
 *
 *  1. 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，
 *     如果类没有进行过初始化，则需要先触发其初始化。
 *     生成这4条指令的最常见的Java代码场景是：
 *     使用new关键字实例化对象的时候、
 *     读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候，
 *     以及调用一个类的静态方法的时候。
 *  2. 使用 java.lang.reflect 包的方法对类进行反射调用的时候，
 *     如果类没有进行过初始化，则需要先触发其初始化。
 *  3. 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
 *  4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），
 *     虚拟机会先初始化这个主类。
 *  5. 当使用 JDK1.7 动态语言支持时，
 *     如果一个 java.lang.invoke.MethodHandle实例最后的解析结果
 *      REF_getstatic,REF_putstatic,REF_invokeStatic 的方法句柄，
 *      并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。
 *
 *
 *  分析一个类的执行顺序大概可以按照如下步骤：
 *  确定类变量的初始值。
 *      在类加载的准备阶段，JVM 会为类变量初始化零值，
 *      这时候类变量会有一个初始的零值。
 *      如果是被 final 修饰的类变量，则直接会被初始成用户想要的值。
 *  初始化入口方法。
 *      当进入类加载的初始化阶段后，
 *      JVM 会寻找整个 main 方法入口，从而初始化 main 方法所在的整个类。
 *      当需要对一个类进行初始化时，会首先初始化类构造器，之后初始化对象构造器。
 *  初始化类构造器。
 *      初始化类构造器是初始化类的第一步，
 *      其会按顺序收集类变量的赋值语句、静态代码块，最终组成类构造器由 JVM 执行。
 *  初始化对象构造器。
 *      初始化对象构造器是在类构造器执行完成之后的第二部操作，
 *      其会按照执行类成员变成赋值、普通代码块、对象构造方法的顺序收集代码，
 *      最终组成对象构造器，最终由 JVM 执行。
 *  如果在初始化 main 方法所在类的时候遇到了其他类的初始化，
 *  那么继续按照初始化类构造器、初始化对象构造器的顺序继续初始化。
 *  如此反复循环，最终返回 main 方法所在类。
 */
public class Book {

    static Book book = new Book();

    static {
        System.out.println("书的静态代码块");
    }

    {
        System.out.println("书的普通代码块");
    }

    Book() {
        System.out.println("书的构造方法");
        System.out.println("price=" + price + ",amount=" + amount);
    }

    public static void staticFunction() {
        System.out.println("书的静态方法");
    }

    int price = 110;
    static int amount = 112;

    public static void main(String[] args) {

        /**
         * 在上面两个例子中，因为 main 方法所在类并没有多余的代码，
         * 我们都直接忽略了 main 方法所在类的初始化。
         * 但在这个例子中，main 方法所在类有许多代码，我们就并不能直接忽略了。
         * 1.当 JVM 在准备阶段的时候，便会为类变量(static修饰)分配内存和进行初始化。
         *   此时，我们的 book 实例变量被初始化为 null，amount 变量被初始化为 0。
         * 2.当进入初始化阶段后，因为 Book 方法是程序的入口，
         *   根据我们上面说到的类初始化的五种情况的第四种：
         *   当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），
         *   虚拟机会先初始化这个主类。JVM 会对 Book 类进行初始化。
         * 3.JVM 对 Book 类进行初始化:
         *   首先是执行类构造器:
         *   （按顺序收集类中所有静态代码块和类变量赋值语句就组成了类构造器），
         *   后执行对象的构造器(new Book()):
         *   （先收集成员变量赋值，后收集普通代码块，最后收集对象构造器，最终组成对象构造器）
         *
         */
        staticFunction();
        System.out.println("amount=" + Book.amount);
    }

}